/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * New Ambition
 * New Ambition REST API
 *
 * OpenAPI spec version: 1.1.0
 * Contact: federico.pastore@bnlmail.com
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://virtserver.swaggerhub.com/jmventura/new_ambition/1.1.0".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * Address object
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {Sensitivity}
     * @memberof Address
     */
    sensitivity?: Sensitivity;
    /**
     * Street name
     * @type {string}
     * @memberof Address
     */
    street?: string;
    /**
     * City name
     * @type {string}
     * @memberof Address
     */
    city?: string;
    /**
     * ISO 3166 country code
     * @type {string}
     * @memberof Address
     */
    country?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof Address
     */
    zipCode?: string;
    /**
     * Falg to determine if this item is the default address
     * @type {boolean}
     * @memberof Address
     */
    _default?: boolean;
}
/**
 * 
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * The Asset identification code
     * @type {string}
     * @memberof Asset
     */
    id?: string;
    /**
     * Code that identifies the type of asset to be insured
     * @type {string}
     * @memberof Asset
     */
    type?: string;
    /**
     * Discount applied on the premium linked to the single asset to be insured
     * @type {number}
     * @memberof Asset
     */
    discount?: number;
    /**
     * 
     * @type {Premium}
     * @memberof Asset
     */
    premium?: Premium;
    /**
     * 
     * @type {Array<Warranty>}
     * @memberof Asset
     */
    warranties?: Array<Warranty>;
    /**
     * 
     * @type {Array<ValueList>}
     * @memberof Asset
     */
    contractTerms?: Array<ValueList>;
    /**
     * Array of subjects (individual or legal entities) connected to the Quotation
     * @type {Array<AssetSubjects>}
     * @memberof Asset
     */
    subjects: Array<AssetSubjects>;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    upDownState?: Asset.UpDownStateEnum;
}

/**
 * @export
 * @namespace Asset
 */
export namespace Asset {
    /**
     * @export
     * @enum {string}
     */
    export enum UpDownStateEnum {
        BUY = <any> 'BUY',
        UP = <any> 'UP'
    }
}
/**
 * 
 * @export
 * @interface AssetSubjects
 */
export interface AssetSubjects {
    /**
     * Flag to determine the subjet type
     * @type {string}
     * @memberof AssetSubjects
     */
    type?: AssetSubjects.TypeEnum;
    /**
     * 
     * @type {LegalEntity | Individual}
     * @memberof AssetSubjects
     */
    entity?: LegalEntity | Individual;
}

/**
 * @export
 * @namespace AssetSubjects
 */
export namespace AssetSubjects {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        LEGALENTITY = <any> 'LEGAL_ENTITY',
        INDIVIDUAL = <any> 'INDIVIDUAL'
    }
}
/**
 * 
 * @export
 * @interface Body
 */
export interface Body {
    /**
     * 
     * @type {QuotationRecalculation}
     * @memberof Body
     */
    quotation?: QuotationRecalculation;
    /**
     * 
     * @type {string}
     * @memberof Body
     */
    operation?: Body.OperationEnum;
}

/**
 * @export
 * @namespace Body
 */
export namespace Body {
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        Upgrade = <any> 'upgrade',
        Downgrade = <any> 'downgrade'
    }
}
/**
 * 
 * @export
 * @interface Body1
 */
export interface Body1 {
    /**
     * 
     * @type {Array<QuotationPatch>}
     * @memberof Body1
     */
    mutations?: Array<QuotationPatch>;
    /**
     * 
     * @type {string}
     * @memberof Body1
     */
    operation?: Body1.OperationEnum;
}

/**
 * @export
 * @namespace Body1
 */
export namespace Body1 {
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        Upgrade = <any> 'upgrade',
        Downgrade = <any> 'downgrade'
    }
}
/**
 * 
 * @export
 * @interface Body2
 */
export interface Body2 {
    /**
     * 
     * @type {Date}
     * @memberof Body2
     */
    validFrom?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Body2
     */
    validTo?: Date;
    /**
     * 
     * @type {Quotation}
     * @memberof Body2
     */
    quotation?: Quotation;
    /**
     * 
     * @type {Address}
     * @memberof Body2
     */
    postalAddress?: Address;
    /**
     * 
     * @type {string}
     * @memberof Body2
     */
    deskCompetence?: string;
    /**
     * 
     * @type {string}
     * @memberof Body2
     */
    deskManagement?: string;
    /**
     * Flag to determine if all the related documentation should be issued digitally or printed
     * @type {boolean}
     * @memberof Body2
     */
    shouldPrint?: boolean;
    /**
     * 
     * @type {Contact}
     * @memberof Body2
     */
    email?: Contact;
    /**
     * List of objects that indicate all completed surveys and their evaluations before generating the proposal
     * @type {Array<SurveySubmission>}
     * @memberof Body2
     */
    surveys?: Array<SurveySubmission>;
}
/**
 * Contact details item
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * Type of contact, sometimes referred as channel
     * @type {string}
     * @memberof Contact
     */
    type?: Contact.TypeEnum;
    /**
     * 
     * @type {Sensitivity}
     * @memberof Contact
     */
    sensitivity?: Sensitivity;
    /**
     * 
     * @type {string | number}
     * @memberof Contact
     */
    value?: string | number;
    /**
     * Flag to determine if the contact item is the default channel
     * @type {boolean}
     * @memberof Contact
     */
    _default?: boolean;
}

/**
 * @export
 * @namespace Contact
 */
export namespace Contact {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        PHONELAND = <any> 'PHONE_LAND',
        PHONEMOBILE = <any> 'PHONE_MOBILE',
        FAX = <any> 'FAX',
        EMAIL = <any> 'EMAIL',
        TWITTER = <any> 'TWITTER',
        FACEBOOK = <any> 'FACEBOOK',
        TELEGRAM = <any> 'TELEGRAM'
    }
}
/**
 * 
 * @export
 * @interface Discount
 */
export interface Discount {
    /**
     * The Discount identification code
     * @type {string}
     * @memberof Discount
     */
    id: string;
    /**
     * Gross discount by type of discount
     * @type {number}
     * @memberof Discount
     */
    grossDiscount: number;
    /**
     * Net discount by type of discount
     * @type {number}
     * @memberof Discount
     */
    netDiscount: number;
}
/**
 * 
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    id: string;
    /**
     * Type code that identifies the type of document. It must be agreed with the company
     * @type {string}
     * @memberof Document
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    description?: string;
    /**
     * Template of document. It must be agreed with the company.
     * @type {string}
     * @memberof Document
     */
    templateId?: string;
    /**
     * The Proposal Id this document refers to. If null, the field “policyId” must be filled
     * @type {string}
     * @memberof Document
     */
    proposalId?: string;
    /**
     * The Policy Id this document refers to. If null, the field “proposalId” must be filled
     * @type {string}
     * @memberof Document
     */
    policyId?: string;
    /**
     * How this document must be signed
     * @type {string}
     * @memberof Document
     */
    signatureMode?: Document.SignatureModeEnum;
    /**
     * Base64 representation of the document bytes
     * @type {string}
     * @memberof Document
     */
    data?: string;
}

/**
 * @export
 * @namespace Document
 */
export namespace Document {
    /**
     * @export
     * @enum {string}
     */
    export enum SignatureModeEnum {
        DIGITAL = <any> 'DIGITAL',
        PAPER = <any> 'PAPER'
    }
}
/**
 * IdentificationDocument Document
 * @export
 * @interface IdentificationDocument
 */
export interface IdentificationDocument {
    /**
     * 
     * @type {string}
     * @memberof IdentificationDocument
     */
    type: IdentificationDocument.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof IdentificationDocument
     */
    code?: string;
    /**
     * 
     * @type {Date}
     * @memberof IdentificationDocument
     */
    expiration?: Date;
    /**
     * 
     * @type {Date}
     * @memberof IdentificationDocument
     */
    releasedOn?: Date;
    /**
     * ISO 3166 country code
     * @type {string}
     * @memberof IdentificationDocument
     */
    releasedIn?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentificationDocument
     */
    releasedBy?: string;
}

/**
 * @export
 * @namespace IdentificationDocument
 */
export namespace IdentificationDocument {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        IDCARD = <any> 'ID_CARD',
        PASSPORT = <any> 'PASSPORT',
        DRIVINGLICENSE = <any> 'DRIVING_LICENSE',
        OTHER = <any> 'OTHER'
    }
}
/**
 * 
 * @export
 * @interface Individual
 */
export interface Individual {
    /**
     * The Company identification code
     * @type {string}
     * @memberof Individual
     */
    id?: string;
    /**
     * 
     * @type {IndividualNames}
     * @memberof Individual
     */
    names?: IndividualNames;
    /**
     * Gender
     * @type {string}
     * @memberof Individual
     */
    gender?: Individual.GenderEnum;
    /**
     * The marital status
     * @type {string}
     * @memberof Individual
     */
    maritalStatus?: Individual.MaritalStatusEnum;
    /**
     * ISO 3166 country code
     * @type {string}
     * @memberof Individual
     */
    nationality?: string;
    /**
     * ISO 3166 country code
     * @type {string}
     * @memberof Individual
     */
    cityzenship1?: string;
    /**
     * ISO 3166 country code
     * @type {string}
     * @memberof Individual
     */
    cityzenship2?: string;
    /**
     * Individual tax code
     * @type {string}
     * @memberof Individual
     */
    tax?: string;
    /**
     * 
     * @type {Array<Address>}
     * @memberof Individual
     */
    addresses?: Array<Address>;
    /**
     * Array of Contact Item filtered by type of phone
     * @type {Array<Contact>}
     * @memberof Individual
     */
    phones?: Array<Contact>;
    /**
     * Array of Contact Item filtered by type of email
     * @type {Array<Contact>}
     * @memberof Individual
     */
    emails?: Array<Contact>;
    /**
     * List of information relating to the individual's IdentificationDocuments
     * @type {Array<IdentificationDocument>}
     * @memberof Individual
     */
    identifications?: Array<IdentificationDocument>;
}

/**
 * @export
 * @namespace Individual
 */
export namespace Individual {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MaritalStatusEnum {
        SINLGE = <any> 'SINLGE',
        MARRIED = <any> 'MARRIED',
        DIVORCED = <any> 'DIVORCED'
    }
}
/**
 * 
 * @export
 * @interface IndividualNames
 */
export interface IndividualNames {
    /**
     * 
     * @type {string}
     * @memberof IndividualNames
     */
    first?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualNames
     */
    middle?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualNames
     */
    last?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualNames
     */
    title?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * The Product Id
     * @type {string}
     * @memberof InlineResponse200
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * The Survey Id
     * @type {string}
     * @memberof InlineResponse2001
     */
    id?: string;
    /**
     * The Survey title
     * @type {string}
     * @memberof InlineResponse2001
     */
    title?: string;
    /**
     * The Survey description
     * @type {string}
     * @memberof InlineResponse2001
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * The Document Id
     * @type {string}
     * @memberof InlineResponse2002
     */
    id?: string;
    /**
     * The Document title
     * @type {string}
     * @memberof InlineResponse2002
     */
    title?: string;
    /**
     * The Document file extension
     * @type {string}
     * @memberof InlineResponse2002
     */
    extension?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse201
 */
export interface InlineResponse201 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse201
     */
    status?: InlineResponse201.StatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse201
     */
    messages?: Array<string>;
}

/**
 * @export
 * @namespace InlineResponse201
 */
export namespace InlineResponse201 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        SUCCESS = <any> 'SUCCESS',
        WARNING = <any> 'WARNING',
        FAIL = <any> 'FAIL'
    }
}
/**
 * 
 * @export
 * @interface LegalEntity
 */
export interface LegalEntity {
    /**
     * The Company identification code
     * @type {string}
     * @memberof LegalEntity
     */
    id?: string;
    /**
     * Company tax code
     * @type {string}
     * @memberof LegalEntity
     */
    tax?: string;
    /**
     * Business name
     * @type {string}
     * @memberof LegalEntity
     */
    name?: string;
    /**
     * Legal form
     * @type {string}
     * @memberof LegalEntity
     */
    form?: LegalEntity.FormEnum;
    /**
     * Activity status code
     * @type {string}
     * @memberof LegalEntity
     */
    statusCode: LegalEntity.StatusCodeEnum;
    /**
     * 
     * @type {LegalEntityCapital}
     * @memberof LegalEntity
     */
    capital: LegalEntityCapital;
    /**
     * 
     * @type {LegalEntityRegistration}
     * @memberof LegalEntity
     */
    registration: LegalEntityRegistration;
    /**
     * 
     * @type {LegalEntityCodes}
     * @memberof LegalEntity
     */
    codes?: LegalEntityCodes;
    /**
     * 
     * @type {Array<LegalEntityContacts>}
     * @memberof LegalEntity
     */
    contacts?: Array<LegalEntityContacts>;
}

/**
 * @export
 * @namespace LegalEntity
 */
export namespace LegalEntity {
    /**
     * @export
     * @enum {string}
     */
    export enum FormEnum {
        SPA = <any> 'SPA',
        SRL = <any> 'SRL',
        SAS = <any> 'SAS'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusCodeEnum {
        A = <any> 'A',
        B = <any> 'B',
        C = <any> 'C'
    }
}
/**
 * Social capital
 * @export
 * @interface LegalEntityCapital
 */
export interface LegalEntityCapital {
    /**
     * Currency code
     * @type {string}
     * @memberof LegalEntityCapital
     */
    currency?: string;
    /**
     * 
     * @type {number}
     * @memberof LegalEntityCapital
     */
    amount?: number;
}
/**
 * 
 * @export
 * @interface LegalEntityCodes
 */
export interface LegalEntityCodes {
    /**
     * 
     * @type {string}
     * @memberof LegalEntityCodes
     */
    sae?: string;
    /**
     * 
     * @type {string}
     * @memberof LegalEntityCodes
     */
    rae?: string;
    /**
     * 
     * @type {string}
     * @memberof LegalEntityCodes
     */
    ateco?: string;
}
/**
 * 
 * @export
 * @interface LegalEntityContacts
 */
export interface LegalEntityContacts {
    /**
     * Role in company
     * @type {string}
     * @memberof LegalEntityContacts
     */
    role?: string;
    /**
     * ISO 639-1 language code
     * @type {string}
     * @memberof LegalEntityContacts
     */
    lang?: string;
    /**
     * 
     * @type {Individual}
     * @memberof LegalEntityContacts
     */
    constact?: Individual;
}
/**
 * 
 * @export
 * @interface LegalEntityRegistration
 */
export interface LegalEntityRegistration {
    /**
     * Registration date of legal entity
     * @type {Date}
     * @memberof LegalEntityRegistration
     */
    date?: Date;
    /**
     * ISO 3166 country code
     * @type {string}
     * @memberof LegalEntityRegistration
     */
    country?: string;
    /**
     * The Main company this one is a branch of
     * @type {string}
     * @memberof LegalEntityRegistration
     */
    mainCompany?: string;
}
/**
 * 
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     * The Policy identification code
     * @type {string}
     * @memberof Policy
     */
    id?: string;
    /**
     * Identifies the type of Policy
     * @type {string}
     * @memberof Policy
     */
    type?: Policy.TypeEnum;
    /**
     * The Product identification code
     * @type {string}
     * @memberof Policy
     */
    productId?: string;
    /**
     * The partner identification code
     * @type {string}
     * @memberof Policy
     */
    parterId?: string;
    /**
     * The Policy status
     * @type {string}
     * @memberof Policy
     */
    status?: Policy.StatusEnum;
    /**
     * 
     * @type {Array<Premium>}
     * @memberof Policy
     */
    premiums?: Array<Premium>;
    /**
     * The Proposal identification code
     * @type {string}
     * @memberof Policy
     */
    proposalId?: string;
}

/**
 * @export
 * @namespace Policy
 */
export namespace Policy {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        INDIVIDUAL = <any> 'INDIVIDUAL',
        GROUP = <any> 'GROUP'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ATTIVA = <any> 'ATTIVA',
        RECESSA = <any> 'RECESSA',
        DISDETTA = <any> 'DISDETTA',
        ANNULLATA = <any> 'ANNULLATA'
    }
}
/**
 * 
 * @export
 * @interface Premium
 */
export interface Premium {
    /**
     * Total premium associated with the all warranties included in a product
     * @type {number}
     * @memberof Premium
     */
    gross: number;
    /**
     * Total premium discounted associated with the all warranties included in a product
     * @type {number}
     * @memberof Premium
     */
    grossDiscount: number;
    /**
     * Total premium without tax associated with the all warranties included in a product
     * @type {number}
     * @memberof Premium
     */
    net?: number;
    /**
     * Is net without SSN tax (ssn)
     * @type {number}
     * @memberof Premium
     */
    noTax?: number;
    /**
     * Is total SSN tax product
     * @type {number}
     * @memberof Premium
     */
    ssn?: number;
    /**
     * Total premium tax associated with the all warranties included in a product
     * @type {number}
     * @memberof Premium
     */
    tax?: number;
    /**
     * Tranche of premium associated with the all warranties included in a product
     * @type {number}
     * @memberof Premium
     */
    trancheGross: number;
    /**
     * Tranche of premium discounted associated with the all warranties included in a product
     * @type {number}
     * @memberof Premium
     */
    trancheGrossDiscount: number;
    /**
     * Tranche of premium without tax associated with the all warranties included in a product
     * @type {number}
     * @memberof Premium
     */
    trancheNet?: number;
    /**
     * tranche_net without SSN tax.
     * @type {number}
     * @memberof Premium
     */
    trancheNoTax?: number;
    /**
     * The tranche of SSN tax of product.
     * @type {number}
     * @memberof Premium
     */
    trancheSsn?: number;
    /**
     * In upgrade policy is the new tranche of premium associated with the all warranties included in a product
     * @type {number}
     * @memberof Premium
     */
    nextTrancheGross?: number;
    /**
     * In upgrade policy is the new tranche of premium discounted associated with the all warranties included in a product
     * @type {number}
     * @memberof Premium
     */
    nextTrancheGrossDiscount?: number;
    /**
     * In upgrade policy is Annual residual premium upon maturity
     * @type {number}
     * @memberof Premium
     */
    remainingDiscount?: number;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    id?: string;
    /**
     * 
     * @type {Array<ProductWarranties>}
     * @memberof Product
     */
    warranties?: Array<ProductWarranties>;
    /**
     * 
     * @type {Array<ProductTooltips>}
     * @memberof Product
     */
    tooltips?: Array<ProductTooltips>;
    /**
     * 
     * @type {Array<ProductSurveys>}
     * @memberof Product
     */
    surveys?: Array<ProductSurveys>;
    /**
     * 
     * @type {Array<ProductAssets>}
     * @memberof Product
     */
    assets?: Array<ProductAssets>;
}
/**
 * 
 * @export
 * @interface ProductAssets
 */
export interface ProductAssets {
    /**
     * The Asset array, the order of items is semantic
     * @type {string}
     * @memberof ProductAssets
     */
    assetId?: string;
}
/**
 * The Surveys array, the order of items is semantic
 * @export
 * @interface ProductSurveys
 */
export interface ProductSurveys {
    /**
     * The Survey Id
     * @type {string}
     * @memberof ProductSurveys
     */
    surveyId?: string;
}
/**
 * 
 * @export
 * @interface ProductTooltips
 */
export interface ProductTooltips {
    /**
     * The field path for the tooltip
     * @type {string}
     * @memberof ProductTooltips
     */
    path?: string;
    /**
     * The tooltip title
     * @type {string}
     * @memberof ProductTooltips
     */
    title?: string;
    /**
     * The tooltip description
     * @type {string}
     * @memberof ProductTooltips
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface ProductWarranties
 */
export interface ProductWarranties {
    /**
     * 
     * @type {Warranty}
     * @memberof ProductWarranties
     */
    warranty?: Warranty;
    /**
     * 
     * @type {Array<SelectionRuleSet>}
     * @memberof ProductWarranties
     */
    selectionRules?: Array<SelectionRuleSet>;
}
/**
 * 
 * @export
 * @interface Proposal
 */
export interface Proposal {
    /**
     * The Proposal identification code
     * @type {string}
     * @memberof Proposal
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface Quotation
 */
export interface Quotation {
    /**
     * The Quotation identification code
     * @type {string}
     * @memberof Quotation
     */
    id?: string;
    /**
     * Unique code of the product
     * @type {string}
     * @memberof Quotation
     */
    productId?: string;
    /**
     * Date from which the insurance policy takes effect
     * @type {Date}
     * @memberof Quotation
     */
    effectDate?: Date;
    /**
     * Code that identifies the type of payment split. The codes are determined by a list of types which has a code identified by the property \"domain_splitting_type\"
     * @type {string}
     * @memberof Quotation
     */
    splitting?: Quotation.SplittingEnum;
    /**
     * 
     * @type {Premium}
     * @memberof Quotation
     */
    premium?: Premium;
    /**
     * Array of customer agreements codes comming from the bank systems
     * @type {Array<string>}
     * @memberof Quotation
     */
    agreements?: Array<string>;
    /**
     * Array of subjects (individual or legal entities) connected to the Quotation
     * @type {Array<QuotationSubjects>}
     * @memberof Quotation
     */
    subjects?: Array<QuotationSubjects>;
    /**
     * Array of Asset to be insured
     * @type {Array<Asset>}
     * @memberof Quotation
     */
    assets?: Array<Asset>;
    /**
     * Array of discounts applied; the total discount amount MUST be calculated by summing all the items together
     * @type {Array<Discount>}
     * @memberof Quotation
     */
    discounts?: Array<Discount>;
    /**
     * Array of Warranty
     * @type {Array<Warranty>}
     * @memberof Quotation
     */
    warranties?: Array<Warranty>;
}

/**
 * @export
 * @namespace Quotation
 */
export namespace Quotation {
    /**
     * @export
     * @enum {string}
     */
    export enum SplittingEnum {
        BIWEEKLY = <any> 'BIWEEKLY',
        MONTHLY = <any> 'MONTHLY',
        QUARTER = <any> 'QUARTER',
        SEMESTER = <any> 'SEMESTER',
        ANNUAL = <any> 'ANNUAL'
    }
}
/**
 * 
 * @export
 * @interface QuotationPatch
 */
export interface QuotationPatch {
    /**
     * 
     * @type {string}
     * @memberof QuotationPatch
     */
    field?: string;
    /**
     * 
     * @type {string | number | boolean | Array<ModelObject> | any}
     * @memberof QuotationPatch
     */
    oldValue?: string | number | boolean | Array<ModelObject> | any;
    /**
     * 
     * @type {string | number | boolean | Array<ModelObject> | any}
     * @memberof QuotationPatch
     */
    newValue?: string | number | boolean | Array<ModelObject> | any;
}
/**
 * 
 * @export
 * @interface QuotationRecalculation
 */
export interface QuotationRecalculation {
    /**
     * 
     * @type {Quotation}
     * @memberof QuotationRecalculation
     */
    oldValue?: Quotation;
    /**
     * 
     * @type {Quotation}
     * @memberof QuotationRecalculation
     */
    newValue?: Quotation;
}
/**
 * 
 * @export
 * @interface QuotationSubjects
 */
export interface QuotationSubjects {
    /**
     * Flag to determine the subjet type
     * @type {string}
     * @memberof QuotationSubjects
     */
    type?: QuotationSubjects.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QuotationSubjects
     */
    role?: QuotationSubjects.RoleEnum;
    /**
     * 
     * @type {Individual | LegalEntity}
     * @memberof QuotationSubjects
     */
    item?: Individual | LegalEntity;
}

/**
 * @export
 * @namespace QuotationSubjects
 */
export namespace QuotationSubjects {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        LEGALENTITY = <any> 'LEGAL_ENTITY',
        INDIVIDUAL = <any> 'INDIVIDUAL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        CONTRAENTE = <any> 'CONTRAENTE',
        BENEFICIARIO = <any> 'BENEFICIARIO',
        ASSICURATO = <any> 'ASSICURATO'
    }
}
/**
 * 
 * @export
 * @interface SelectionRule
 */
export interface SelectionRule {
    /**
     * Points to a Warranty
     * @type {string}
     * @memberof SelectionRule
     */
    warrantyId?: string;
    /**
     * 
     * @type {string}
     * @memberof SelectionRule
     */
    state?: SelectionRule.StateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof SelectionRule
     */
    value?: boolean;
}

/**
 * @export
 * @namespace SelectionRule
 */
export namespace SelectionRule {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Enabled = <any> 'enabled',
        Required = <any> 'required',
        Selected = <any> 'selected'
    }
}
/**
 * Set of selection rules for client validation
 * @export
 * @interface SelectionRuleSet
 */
export interface SelectionRuleSet {
    /**
     * 
     * @type {Array<SelectionRule>}
     * @memberof SelectionRuleSet
     */
    required?: Array<SelectionRule>;
    /**
     * 
     * @type {Array<SelectionRule>}
     * @memberof SelectionRuleSet
     */
    enabled?: Array<SelectionRule>;
    /**
     * 
     * @type {Array<SelectionRule>}
     * @memberof SelectionRuleSet
     */
    selected?: Array<SelectionRule>;
}
/**
 * Sensitivity values
 * @export
 * @enum {string}
 */
export enum Sensitivity {
    HOME = <any> 'HOME',
    WORK = <any> 'WORK',
    ASSISTANT = <any> 'ASSISTANT',
    OTHER = <any> 'OTHER'
}
/**
 * 
 * @export
 * @interface Survey
 */
export interface Survey {
    /**
     * The Product identification code for the Product the Survey applies to
     * @type {string}
     * @memberof Survey
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Survey
     */
    productId: string;
    /**
     * 
     * @type {string}
     * @memberof Survey
     */
    title: string;
    /**
     * 
     * @type {Array<SurveySections>}
     * @memberof Survey
     */
    sections?: Array<SurveySections>;
}
/**
 * 
 * @export
 * @interface SurveyQuestion
 */
export interface SurveyQuestion {
    /**
     * The Question identification code
     * @type {string}
     * @memberof SurveyQuestion
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SurveyQuestion
     */
    title: string;
    /**
     * 
     * @type {Array<SurveyQuestionChoice>}
     * @memberof SurveyQuestion
     */
    choices: Array<SurveyQuestionChoice>;
    /**
     * 
     * @type {boolean}
     * @memberof SurveyQuestion
     */
    multiple: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SurveyQuestion
     */
    required: boolean;
}
/**
 * 
 * @export
 * @interface SurveyQuestionAnswer
 */
export interface SurveyQuestionAnswer {
    /**
     * The Question identification code
     * @type {string}
     * @memberof SurveyQuestionAnswer
     */
    questionId?: string;
    /**
     * 
     * @type {Array<SurveyQuestionAnswerAnswers>}
     * @memberof SurveyQuestionAnswer
     */
    answers?: Array<SurveyQuestionAnswerAnswers>;
}
/**
 * 
 * @export
 * @interface SurveyQuestionAnswerAnswers
 */
export interface SurveyQuestionAnswerAnswers {
    /**
     * The Choice identification code
     * @type {string}
     * @memberof SurveyQuestionAnswerAnswers
     */
    choiceId?: string;
    /**
     * The user selection
     * @type {string}
     * @memberof SurveyQuestionAnswerAnswers
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface SurveyQuestionChoice
 */
export interface SurveyQuestionChoice {
    /**
     * The Choice identification code
     * @type {string}
     * @memberof SurveyQuestionChoice
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SurveyQuestionChoice
     */
    title?: string;
}
/**
 * 
 * @export
 * @interface SurveySections
 */
export interface SurveySections {
    /**
     * 
     * @type {string}
     * @memberof SurveySections
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof SurveySections
     */
    description?: string;
    /**
     * 
     * @type {Array<SurveyQuestion>}
     * @memberof SurveySections
     */
    questions?: Array<SurveyQuestion>;
}
/**
 * 
 * @export
 * @interface SurveySubmission
 */
export interface SurveySubmission {
    /**
     * The Survey identification code
     * @type {string}
     * @memberof SurveySubmission
     */
    surveyId?: string;
    /**
     * 
     * @type {string}
     * @memberof SurveySubmission
     */
    customerId?: string;
    /**
     * 
     * @type {string}
     * @memberof SurveySubmission
     */
    productId?: string;
    /**
     * 
     * @type {Array<SurveyQuestionAnswer>}
     * @memberof SurveySubmission
     */
    answers?: Array<SurveyQuestionAnswer>;
}
/**
 * 
 * @export
 * @interface ValueList
 */
export interface ValueList {
    /**
     * 
     * @type {string}
     * @memberof ValueList
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueList
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueList
     */
    description?: string;
    /**
     * 
     * @type {Array<ValueListItem>}
     * @memberof ValueList
     */
    values?: Array<ValueListItem>;
}
/**
 * 
 * @export
 * @interface ValueListItem
 */
export interface ValueListItem {
    /**
     * The value list item identification code
     * @type {string}
     * @memberof ValueListItem
     */
    id?: string;
    /**
     * The value list item title
     * @type {string}
     * @memberof ValueListItem
     */
    title?: string;
    /**
     * 
     * @type {string | number}
     * @memberof ValueListItem
     */
    value?: string | number;
}
/**
 * 
 * @export
 * @interface Warranty
 */
export interface Warranty {
    /**
     * 
     * @type {string}
     * @memberof Warranty
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Warranty
     */
    title?: string;
    /**
     * Description of the Warranty
     * @type {string}
     * @memberof Warranty
     */
    description: string;
    /**
     * The aggregation key for this type/cetegory of warranty
     * @type {string}
     * @memberof Warranty
     */
    categoryId: string;
    /**
     * 
     * @type {WarrantyState}
     * @memberof Warranty
     */
    state: WarrantyState;
    /**
     * 
     * @type {SelectionRuleSet}
     * @memberof Warranty
     */
    selectionRules?: SelectionRuleSet;
    /**
     * 
     * @type {Premium}
     * @memberof Warranty
     */
    premium?: Premium;
}
/**
 * 
 * @export
 * @interface WarrantyState
 */
export interface WarrantyState {
    /**
     * 
     * @type {boolean}
     * @memberof WarrantyState
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WarrantyState
     */
    selected?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WarrantyState
     */
    required?: boolean;
}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Policy
         * @summary Create a Policy
         * @param {Policy} body The data structure needed to create a Policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy(body: Policy, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPolicy.');
            }
            const localVarPath = `/policies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Policy" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Proposal from a Quotation?
         * @summary Create Proposal
         * @param {Body2} body The data structure needed to create a Proposal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProposal(body: Body2, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createProposal.');
            }
            const localVarPath = `/proposals`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Body2" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Product Quotation
         * @summary Create a Quotation
         * @param {Quotation} body The Quotation to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuotation(body: Quotation, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createQuotation.');
            }
            const localVarPath = `/quotations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Quotation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all documents for a certain Proposal or Policy
         * @param {string} [proposalId] The Proposal Id
         * @param {string} [policyId] The Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsGet(proposalId?: string, policyId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/documents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (proposalId !== undefined) {
                localVarQueryParameter['proposal_id'] = proposalId;
            }

            if (policyId !== undefined) {
                localVarQueryParameter['policy_id'] = policyId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Document by Id
         * @param {string} id The Document Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling documentsIdGet.');
            }
            const localVarPath = `/documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Policy by Id
         * @summary Get a Policy
         * @param {string} id The Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPolicy.');
            }
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Proposal by Id
         * @summary Get a Proposal
         * @param {string} id The Quotation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProposal(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProposal.');
            }
            const localVarPath = `/proposals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single Survey by passing its Id
         * @summary Get Survey by Id
         * @param {string} id pass the Survey Id to get Survey object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSurvey(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSurvey.');
            }
            const localVarPath = `/survey/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a value list items
         * @summary Get a value list items
         * @param {string} id The value list id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValuelists(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getValuelists.');
            }
            const localVarPath = `/value-lists/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All the available Surveys for a given Product can be listed by passing in the appropriate Product Id
         * @summary List available Surveys for a given Product
         * @param {string} productId pass the Product Id to list the available Surveys
         * @param {string} subjectType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSurveys(productId: string, subjectType: string, options: any = {}): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling listSurveys.');
            }
            // verify required parameter 'subjectType' is not null or undefined
            if (subjectType === null || subjectType === undefined) {
                throw new RequiredError('subjectType','Required parameter subjectType was null or undefined when calling listSurveys.');
            }
            const localVarPath = `/surveys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (productId !== undefined) {
                localVarQueryParameter['product_id'] = productId;
            }

            if (subjectType !== undefined) {
                localVarQueryParameter['subject_type'] = subjectType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all available value lists
         * @summary List all available value lists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listValuelists(options: any = {}): FetchArgs {
            const localVarPath = `/value-lists`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recalculate a Quotation by patching it
         * @param {Body1} body The Quotation to be patched
         * @param {string} id The Quotation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchQuotation(body: Body1, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchQuotation.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patchQuotation.');
            }
            const localVarPath = `/quotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Body1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Product list
         * @param {string} [category] The Product category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet(category?: string, options: any = {}): FetchArgs {
            const localVarPath = `/products`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get product by Id
         * @param {string} id The Document Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling productsIdGet.');
            }
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Evaluate a Survey Submission before to move forward the sales process
         * @summary Submit a Survey result
         * @param {SurveySubmission} body The Survey results Submission
         * @param {string} id pass the Survey Id to submit the Survey result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSurvey(body: SurveySubmission, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling submitSurvey.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling submitSurvey.');
            }
            const localVarPath = `/survey/{id}/submissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SurveySubmission" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Policy
         * @param {Policy} body The data structure needed to create a Policy
         * @param {string} id The Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(body: Policy, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePolicy.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePolicy.');
            }
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Policy" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Proposal
         * @param {Quotation} body The data structure needed to create a Proposal
         * @param {string} id The Proposal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProposal(body: Quotation, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProposal.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateProposal.');
            }
            const localVarPath = `/proposals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Quotation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upgrade or Downgrade a product Quotation
         * @param {Body} body The Quotation to be updated
         * @param {string} id The Quotation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuotation(body: Body, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateQuotation.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateQuotation.');
            }
            const localVarPath = `/quotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Body" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a Policy
         * @summary Create a Policy
         * @param {Policy} body The data structure needed to create a Policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy(body: Policy, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Policy> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).createPolicy(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a Proposal from a Quotation?
         * @summary Create Proposal
         * @param {Body2} body The data structure needed to create a Proposal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProposal(body: Body2, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Proposal> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).createProposal(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a Product Quotation
         * @summary Create a Quotation
         * @param {Quotation} body The Quotation to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuotation(body: Quotation, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Quotation> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).createQuotation(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all documents for a certain Proposal or Policy
         * @param {string} [proposalId] The Proposal Id
         * @param {string} [policyId] The Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsGet(proposalId?: string, policyId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2002>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).documentsGet(proposalId, policyId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a Document by Id
         * @param {string} id The Document Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Document> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).documentsIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a Policy by Id
         * @summary Get a Policy
         * @param {string} id The Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Policy> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getPolicy(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a Proposal by Id
         * @summary Get a Proposal
         * @param {string} id The Quotation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProposal(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Proposal> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getProposal(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a single Survey by passing its Id
         * @summary Get Survey by Id
         * @param {string} id pass the Survey Id to get Survey object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSurvey(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Survey> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getSurvey(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a value list items
         * @summary Get a value list items
         * @param {string} id The value list id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValuelists(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ValueList> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getValuelists(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * All the available Surveys for a given Product can be listed by passing in the appropriate Product Id
         * @summary List available Surveys for a given Product
         * @param {string} productId pass the Product Id to list the available Surveys
         * @param {string} subjectType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSurveys(productId: string, subjectType: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2001>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).listSurveys(productId, subjectType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all available value lists
         * @summary List all available value lists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listValuelists(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ValueList>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).listValuelists(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Recalculate a Quotation by patching it
         * @param {Body1} body The Quotation to be patched
         * @param {string} id The Quotation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchQuotation(body: Body1, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Quotation> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).patchQuotation(body, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Product list
         * @param {string} [category] The Product category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet(category?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse200>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).productsGet(category, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get product by Id
         * @param {string} id The Document Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).productsIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Evaluate a Survey Submission before to move forward the sales process
         * @summary Submit a Survey result
         * @param {SurveySubmission} body The Survey results Submission
         * @param {string} id pass the Survey Id to submit the Survey result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSurvey(body: SurveySubmission, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).submitSurvey(body, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a Policy
         * @param {Policy} body The data structure needed to create a Policy
         * @param {string} id The Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(body: Policy, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Policy> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).updatePolicy(body, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a Proposal
         * @param {Quotation} body The data structure needed to create a Proposal
         * @param {string} id The Proposal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProposal(body: Quotation, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Proposal> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).updateProposal(body, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Upgrade or Downgrade a product Quotation
         * @param {Body} body The Quotation to be updated
         * @param {string} id The Quotation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuotation(body: Body, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Quotation> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).updateQuotation(body, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a Policy
         * @summary Create a Policy
         * @param {Policy} body The data structure needed to create a Policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy(body: Policy, options?: any) {
            return DefaultApiFp(configuration).createPolicy(body, options)(fetch, basePath);
        },
        /**
         * Create a Proposal from a Quotation?
         * @summary Create Proposal
         * @param {Body2} body The data structure needed to create a Proposal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProposal(body: Body2, options?: any) {
            return DefaultApiFp(configuration).createProposal(body, options)(fetch, basePath);
        },
        /**
         * Create a Product Quotation
         * @summary Create a Quotation
         * @param {Quotation} body The Quotation to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuotation(body: Quotation, options?: any) {
            return DefaultApiFp(configuration).createQuotation(body, options)(fetch, basePath);
        },
        /**
         * List all documents for a certain Proposal or Policy
         * @param {string} [proposalId] The Proposal Id
         * @param {string} [policyId] The Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsGet(proposalId?: string, policyId?: string, options?: any) {
            return DefaultApiFp(configuration).documentsGet(proposalId, policyId, options)(fetch, basePath);
        },
        /**
         * Get a Document by Id
         * @param {string} id The Document Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsIdGet(id: string, options?: any) {
            return DefaultApiFp(configuration).documentsIdGet(id, options)(fetch, basePath);
        },
        /**
         * Get a Policy by Id
         * @summary Get a Policy
         * @param {string} id The Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy(id: string, options?: any) {
            return DefaultApiFp(configuration).getPolicy(id, options)(fetch, basePath);
        },
        /**
         * Get a Proposal by Id
         * @summary Get a Proposal
         * @param {string} id The Quotation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProposal(id: string, options?: any) {
            return DefaultApiFp(configuration).getProposal(id, options)(fetch, basePath);
        },
        /**
         * Get a single Survey by passing its Id
         * @summary Get Survey by Id
         * @param {string} id pass the Survey Id to get Survey object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSurvey(id: string, options?: any) {
            return DefaultApiFp(configuration).getSurvey(id, options)(fetch, basePath);
        },
        /**
         * Get a value list items
         * @summary Get a value list items
         * @param {string} id The value list id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValuelists(id: string, options?: any) {
            return DefaultApiFp(configuration).getValuelists(id, options)(fetch, basePath);
        },
        /**
         * All the available Surveys for a given Product can be listed by passing in the appropriate Product Id
         * @summary List available Surveys for a given Product
         * @param {string} productId pass the Product Id to list the available Surveys
         * @param {string} subjectType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSurveys(productId: string, subjectType: string, options?: any) {
            return DefaultApiFp(configuration).listSurveys(productId, subjectType, options)(fetch, basePath);
        },
        /**
         * List all available value lists
         * @summary List all available value lists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listValuelists(options?: any) {
            return DefaultApiFp(configuration).listValuelists(options)(fetch, basePath);
        },
        /**
         * Recalculate a Quotation by patching it
         * @param {Body1} body The Quotation to be patched
         * @param {string} id The Quotation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchQuotation(body: Body1, id: string, options?: any) {
            return DefaultApiFp(configuration).patchQuotation(body, id, options)(fetch, basePath);
        },
        /**
         * Get Product list
         * @param {string} [category] The Product category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet(category?: string, options?: any) {
            return DefaultApiFp(configuration).productsGet(category, options)(fetch, basePath);
        },
        /**
         * Get product by Id
         * @param {string} id The Document Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsIdGet(id: string, options?: any) {
            return DefaultApiFp(configuration).productsIdGet(id, options)(fetch, basePath);
        },
        /**
         * Evaluate a Survey Submission before to move forward the sales process
         * @summary Submit a Survey result
         * @param {SurveySubmission} body The Survey results Submission
         * @param {string} id pass the Survey Id to submit the Survey result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSurvey(body: SurveySubmission, id: string, options?: any) {
            return DefaultApiFp(configuration).submitSurvey(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a Policy
         * @param {Policy} body The data structure needed to create a Policy
         * @param {string} id The Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(body: Policy, id: string, options?: any) {
            return DefaultApiFp(configuration).updatePolicy(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a Proposal
         * @param {Quotation} body The data structure needed to create a Proposal
         * @param {string} id The Proposal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProposal(body: Quotation, id: string, options?: any) {
            return DefaultApiFp(configuration).updateProposal(body, id, options)(fetch, basePath);
        },
        /**
         * Upgrade or Downgrade a product Quotation
         * @param {Body} body The Quotation to be updated
         * @param {string} id The Quotation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuotation(body: Body, id: string, options?: any) {
            return DefaultApiFp(configuration).updateQuotation(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Create a Policy
     * @summary Create a Policy
     * @param {Policy} body The data structure needed to create a Policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createPolicy(body: Policy, options?: any) {
        return DefaultApiFp(this.configuration).createPolicy(body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a Proposal from a Quotation?
     * @summary Create Proposal
     * @param {Body2} body The data structure needed to create a Proposal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createProposal(body: Body2, options?: any) {
        return DefaultApiFp(this.configuration).createProposal(body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a Product Quotation
     * @summary Create a Quotation
     * @param {Quotation} body The Quotation to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createQuotation(body: Quotation, options?: any) {
        return DefaultApiFp(this.configuration).createQuotation(body, options)(this.fetch, this.basePath);
    }

    /**
     * List all documents for a certain Proposal or Policy
     * @param {string} [proposalId] The Proposal Id
     * @param {string} [policyId] The Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentsGet(proposalId?: string, policyId?: string, options?: any) {
        return DefaultApiFp(this.configuration).documentsGet(proposalId, policyId, options)(this.fetch, this.basePath);
    }

    /**
     * Get a Document by Id
     * @param {string} id The Document Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentsIdGet(id: string, options?: any) {
        return DefaultApiFp(this.configuration).documentsIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get a Policy by Id
     * @summary Get a Policy
     * @param {string} id The Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPolicy(id: string, options?: any) {
        return DefaultApiFp(this.configuration).getPolicy(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get a Proposal by Id
     * @summary Get a Proposal
     * @param {string} id The Quotation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProposal(id: string, options?: any) {
        return DefaultApiFp(this.configuration).getProposal(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get a single Survey by passing its Id
     * @summary Get Survey by Id
     * @param {string} id pass the Survey Id to get Survey object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSurvey(id: string, options?: any) {
        return DefaultApiFp(this.configuration).getSurvey(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get a value list items
     * @summary Get a value list items
     * @param {string} id The value list id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getValuelists(id: string, options?: any) {
        return DefaultApiFp(this.configuration).getValuelists(id, options)(this.fetch, this.basePath);
    }

    /**
     * All the available Surveys for a given Product can be listed by passing in the appropriate Product Id
     * @summary List available Surveys for a given Product
     * @param {string} productId pass the Product Id to list the available Surveys
     * @param {string} subjectType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSurveys(productId: string, subjectType: string, options?: any) {
        return DefaultApiFp(this.configuration).listSurveys(productId, subjectType, options)(this.fetch, this.basePath);
    }

    /**
     * List all available value lists
     * @summary List all available value lists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listValuelists(options?: any) {
        return DefaultApiFp(this.configuration).listValuelists(options)(this.fetch, this.basePath);
    }

    /**
     * Recalculate a Quotation by patching it
     * @param {Body1} body The Quotation to be patched
     * @param {string} id The Quotation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public patchQuotation(body: Body1, id: string, options?: any) {
        return DefaultApiFp(this.configuration).patchQuotation(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * Get Product list
     * @param {string} [category] The Product category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public productsGet(category?: string, options?: any) {
        return DefaultApiFp(this.configuration).productsGet(category, options)(this.fetch, this.basePath);
    }

    /**
     * Get product by Id
     * @param {string} id The Document Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public productsIdGet(id: string, options?: any) {
        return DefaultApiFp(this.configuration).productsIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Evaluate a Survey Submission before to move forward the sales process
     * @summary Submit a Survey result
     * @param {SurveySubmission} body The Survey results Submission
     * @param {string} id pass the Survey Id to submit the Survey result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public submitSurvey(body: SurveySubmission, id: string, options?: any) {
        return DefaultApiFp(this.configuration).submitSurvey(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a Policy
     * @param {Policy} body The data structure needed to create a Policy
     * @param {string} id The Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updatePolicy(body: Policy, id: string, options?: any) {
        return DefaultApiFp(this.configuration).updatePolicy(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a Proposal
     * @param {Quotation} body The data structure needed to create a Proposal
     * @param {string} id The Proposal Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateProposal(body: Quotation, id: string, options?: any) {
        return DefaultApiFp(this.configuration).updateProposal(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * Upgrade or Downgrade a product Quotation
     * @param {Body} body The Quotation to be updated
     * @param {string} id The Quotation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateQuotation(body: Body, id: string, options?: any) {
        return DefaultApiFp(this.configuration).updateQuotation(body, id, options)(this.fetch, this.basePath);
    }

}
